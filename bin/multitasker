#! /usr/bin/env node

process.title = 'multitasker';

var fs = require('fs'),
  path = require('path'),
  program = require('commander'),
  colors = require('colors'),
  moment = require('moment'),
  _ = require('underscore-node');

program
  .version('0.0.1');

program
  .command('exec <tag> <commands...>')
  .description('execute the given commands in the directories tagged with the given tag')
  .option('-s, --serial', 'execute the command in each directory serially instead of in parallel')
  .action(function(tag, commands) {
    console.log('exec');
    console.log('tag: ', tag);
    console.log('commands: ', commands);
  });

program
  .command('tag <tag> [dirs...]')
  .description('tag the current directory (or given directories)')
  .action(function(tag, dirs) {
    var config = readConfig();
    if (!config[tag]) { config[tag] = []; }
    if (!dirs.length) { dirs.push(process.cwd()); }
    config[tag] = _.uniq(
      config[tag].concat(
        dirs.map(function(dir) {
          return path.resolve(dir);
        })
      )
    );
    writeConfig(config);
  });

program
  .command('untag <tag> [dirs...]')
  .description('untag the current directory (or given directories)')
  .action(function(tag, dirs) {
    var config = readConfig();
    if (!dirs.length) { dirs.push(process.cwd()); }
    if (_.isArray(config[tag])) {
      config[tag] = _.without.apply(this,
        [config[tag]].concat(dirs.map(function(dir) { return path.resolve(dir); }))
      );
    }
    if (_.isEmpty(config[tag])) { delete config[tag]; }
    writeConfig(config);
  });

program
  .command('tags')
  .description('list all tags')
  .option('-r, --reverse', 'list tags by directory rather than by tag')
  .action(function(program) {
    var config = readConfig(),
      keys,
      tag;
    if (_.isEmpty(config)) {
      console.log('No tags. Run `multitasker tag -h` to see how to tag directories.'.blue)
    }
    else {
      if (program.reverse) {
        config = reverseTags(config);
      }
      keys = _.keys(_.omit(config, function(value) { return !_.isEmpty(value); })).sort();
      keys.forEach(function(key) {
        console.log(key.green, '=>'.cyan, config[key].sort().join(', ').blue);
      });
    }
  });

program.parse(process.argv);

function reverseTags(tags) {
  var tag,
    dirs = {};
  for (tag in tags) {
    tags[tag].forEach(function(dir) {
      if (!dirs[dir]) { dirs[dir] = []; }
      dirs[dir].push(tag);
    });
  }
  return dirs;
}

function getConfigPath() {
  var home = process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE;
  return path.join(home, '.multitasker.conf');
}

function readConfig() {
  try {
    return JSON.parse(fs.readFileSync(getConfigPath()));
  } catch(e) {
    return {};
  }
}

function writeConfig(config) {
  fs.writeFileSync(getConfigPath(), JSON.stringify(config));
}
